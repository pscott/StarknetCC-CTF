"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateChecksumAddress = exports.getChecksumAddress = exports.validateAndParseAddress = exports.addAddressPadding = void 0;
/* eslint-disable no-bitwise */
var bytes_1 = require("@ethersproject/bytes");
var constants_1 = require("../constants");
var encode_1 = require("./encode");
var hash_1 = require("./hash");
var number_1 = require("./number");
function addAddressPadding(address) {
    return (0, encode_1.addHexPrefix)((0, encode_1.removeHexPrefix)((0, number_1.toHex)((0, number_1.toBN)(address))).padStart(64, '0'));
}
exports.addAddressPadding = addAddressPadding;
function validateAndParseAddress(address) {
    (0, number_1.assertInRange)(address, constants_1.ZERO, constants_1.MASK_251, 'Starknet Address');
    var result = addAddressPadding(address);
    if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {
        throw new Error('Invalid Address Format');
    }
    return result;
}
exports.validateAndParseAddress = validateAndParseAddress;
// from https://github.com/ethers-io/ethers.js/blob/fc1e006575d59792fa97b4efb9ea2f8cca1944cf/packages/address/src.ts/index.ts#L12
function getChecksumAddress(address) {
    var chars = (0, encode_1.removeHexPrefix)(validateAndParseAddress(address)).toLowerCase().split('');
    var hashed = (0, bytes_1.arrayify)((0, hash_1.keccakBn)(address), { hexPad: 'left' }); // in case the hash is 251 bits (63 chars) we need to pad it to 64 chars without changing the number value ("left")
    for (var i = 0; i < chars.length; i += 2) {
        if (hashed[i >> 1] >> 4 >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return (0, encode_1.addHexPrefix)(chars.join(''));
}
exports.getChecksumAddress = getChecksumAddress;
function validateChecksumAddress(address) {
    return getChecksumAddress(address) === address;
}
exports.validateChecksumAddress = validateChecksumAddress;
