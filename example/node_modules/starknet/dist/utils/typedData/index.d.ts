import { BigNumberish } from '../number';
import { StarkNetMerkleType, StarkNetType, TypedData } from './types';
export * from './types';
export declare function prepareSelector(selector: string): string;
export declare function isMerkleTreeType(type: StarkNetType): type is StarkNetMerkleType;
interface Context {
    parent?: string;
    key?: string;
}
/**
 * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once
 * in the resulting array.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @param {string[]} [dependencies]
 * @return {string[]}
 */
export declare const getDependencies: (types: TypedData['types'], type: string, dependencies?: string[]) => string[];
/**
 * Encode a type to a string. All dependant types are alphabetically sorted.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @return {string}
 */
export declare const encodeType: (types: TypedData['types'], type: string) => string;
/**
 * Get a type string as hash.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @return {string}
 */
export declare const getTypeHash: (types: TypedData['types'], type: string) => string;
/**
 * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of
 * an array of ABI compatible types, and an array of corresponding values.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @param {any} data
 * @returns {[string, string]}
 */
export declare const encodeValue: (types: TypedData['types'], type: string, data: unknown, ctx?: Context) => [string, string];
/**
 * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All
 * dependant types are automatically encoded.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @param {Record<string, any>} data
 */
export declare const encodeData: <T extends TypedData>(types: T["types"], type: string, data: T["message"]) => string[][];
/**
 * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant
 * types are automatically encoded.
 *
 * @param {TypedData} typedData
 * @param {string} type
 * @param {Record<string, any>} data
 * @return {Buffer}
 */
export declare const getStructHash: <T extends TypedData>(types: T["types"], type: string, data: T["message"]) => string;
/**
 * Get the EIP-191 encoded message to sign, from the typedData object.
 *
 * @param {TypedData} typedData
 * @param {BigNumberish} account
 * @return {string}
 */
export declare const getMessageHash: (typedData: TypedData, account: BigNumberish) => string;
